let grid = [];
let gridSize = 15;
let islands = [];
let agents = [];
let gates = [];

let gui;
let ctrl;

let creatingIsland = false;
let creatingGate = false;

let logging = true;
let logger;

function Controls(){
  this.addLanguage = function(){
    let v = prompt("Start the language of the island with a vocabulary word");
    let newWord = new Word(v, floor(random(100000)));
    let i = new Island(islands.length, color(random(360), 100, 90), newWord);
    islands.push(i);
    let f = gui.addFolder("Language " + i.id);
    f.add(i, 'nextWord').listen();
    f.add(i, 'addWord');
    f.add(i, 'populate');
    f.open();
    creatingIsland = true;
  }
  this.addGate = function(){
    let g = new Gate();
    gates.push(g);
    creatingGate = true;
  }
}

//word placeholder

function Gate(){
  this.points = [];
}

//agent placeholder

//island placeholder

function GridItem(x_, y_, type_, gx_, gy_){
  //item's location on the canvas
  this.x = x_;
  this.y = y_;
  //item's location in grid array
  this.gridX = gx_;
  this.gridY = gy_;
  this.type = type_;
  this.currentAgent = false;
  this.gateTo;
}

function setup(){
  createCanvas(15 * floor(window.innerWidth / 15), 15 * floor(window.innerHeight/15));
  colorMode(HSL);
  noStroke();
  textFont("Courier New");

  logger = createDiv("");
  logger.id("logger");

  //initialize gui
  ctrl = new Controls();
  gui = new dat.GUI();
  gui.add(ctrl, 'addLanguage');
  gui.add(ctrl, 'addGate');

  //create grid
  for(let i = 0; i < width; i+=15){
    let col = [];
    for(let j = 0; j < height; j+=15){
      col.push(new GridItem(i, j, 'ocean', grid.length, col.length));
    }
    grid.push(col);
  }
}

function draw(){
  background(255);

  //draw islands
  for(let i of islands){
    for(let p of i.points){
      fill(i.color);
      rect(p.x, p.y, 15, 15);
    }
  }

  //draw cursor
  fill(90);
  rect(15 * floor(mouseX/15), 15 * floor(mouseY/15), 15, 15);

  //create new islands if in proper mode
  if(mouseIsPressed){
    if(creatingIsland && grid[floor(mouseX/15)] && grid[floor(mouseX/15)][floor(mouseY/15)]){
      //if we haven't added this point to the new island, add it
      if(!islands[islands.length - 1].points.includes(grid[floor(mouseX/15)][floor(mouseY/15)])){
        islands[islands.length - 1].points.push(grid[floor(mouseX/15)][floor(mouseY/15)]);
        //also change the type of the grid tile to the island's id
        grid[floor(mouseX/15)][floor(mouseY/15)].type = islands.length - 1;
      }
    }
  }

  for(let g of gates){
    stroke(80);
    if(g.points.length == 2){
      line(g.points[0].x + 7.5, g.points[0].y + 7.5, g.points[1].x + 7.5, g.points[1].y + 7.5);
    }
    noStroke();
    for(let p of g.points){
      fill(95);
      rect(p.x, p.y, 15, 15);
    }
  }

  //draw agents
  for(let agent of agents){
    agent.draw();
  }

  if(logging){
    fill(40);
    textStyle(NORMAL);
    textSize(48);
    text("Remark.", 10, 36);
    textSize(18);
    fill(60);
    text("A Language Evolution Simulator", 225, 36);
    for(let i = 0; i < islands.length; i++){
      fill(islands[i].color);
      textSize(28);
      rect(14, 67 + (i * 70), 20, 53);
      fill(40);
      textStyle(NORMAL);
      text("Language " + i, 39, 85 + (i * 70));
      textSize(18);
      textStyle(ITALIC);
      let vocabString = "";
      for(let j = 0; j < islands[i].vocabulary.length; j++){
        if(j > 0){
          vocabString += ", ";
        }
        vocabString += islands[i].vocabulary[j].content;
      }
      text(vocabString, 39, 110 + (i * 70));
    }
  }
}

function mousePressed(){
  if(creatingGate){
    let currentGate = gates[gates.length - 1];
    switch(currentGate.points.length){
      case 0:
        currentGate.points.push(grid[floor(mouseX/15)][floor(mouseY/15)]);
        grid[floor(mouseX/15)][floor(mouseY/15)].type = 'gate';
        break;
      case 1:
        currentGate.points.push(grid[floor(mouseX/15)][floor(mouseY/15)]);
        grid[floor(mouseX/15)][floor(mouseY/15)].type = 'gate';

        let aX = currentGate.points[0].gridX;
        let aY = currentGate.points[0].gridY;
        let bX = currentGate.points[1].gridX;
        let bY = currentGate.points[1].gridY;

        grid[aX][aY].gateTo = grid[bX][bY];
        grid[bX][bY].gateTo = grid[aX][aY];

        creatingGate = false;
        break;
    }
  }
}

function mouseReleased(){
  if(creatingIsland){
    console.log(islands[islands.length-1]);
    //populate island with agents
    // islands[islands.length - 1].populate(floor(random(islands[islands.length-1].points.length / 4)) + 1);
    creatingIsland = false;
  }
}

function keyPressed(){
  switch(keyCode){
    case 76:
      if(logging){
        logging = false;
        logger.hide();
      }else{
        logging = true;
        logger.show();
      }
      break;
    default:
      // console.log(keyCode);
      break;
  }
}

//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJtYWluLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBncmlkID0gW107XG5sZXQgZ3JpZFNpemUgPSAxNTtcbmxldCBpc2xhbmRzID0gW107XG5sZXQgYWdlbnRzID0gW107XG5sZXQgZ2F0ZXMgPSBbXTtcblxubGV0IGd1aTtcbmxldCBjdHJsO1xuXG5sZXQgY3JlYXRpbmdJc2xhbmQgPSBmYWxzZTtcbmxldCBjcmVhdGluZ0dhdGUgPSBmYWxzZTtcblxubGV0IGxvZ2dpbmcgPSB0cnVlO1xubGV0IGxvZ2dlcjtcblxuZnVuY3Rpb24gQ29udHJvbHMoKXtcbiAgdGhpcy5hZGRMYW5ndWFnZSA9IGZ1bmN0aW9uKCl7XG4gICAgbGV0IHYgPSBwcm9tcHQoXCJTdGFydCB0aGUgbGFuZ3VhZ2Ugb2YgdGhlIGlzbGFuZCB3aXRoIGEgdm9jYWJ1bGFyeSB3b3JkXCIpO1xuICAgIGxldCBuZXdXb3JkID0gbmV3IFdvcmQodiwgZmxvb3IocmFuZG9tKDEwMDAwMCkpKTtcbiAgICBsZXQgaSA9IG5ldyBJc2xhbmQoaXNsYW5kcy5sZW5ndGgsIGNvbG9yKHJhbmRvbSgzNjApLCAxMDAsIDkwKSwgbmV3V29yZCk7XG4gICAgaXNsYW5kcy5wdXNoKGkpO1xuICAgIGxldCBmID0gZ3VpLmFkZEZvbGRlcihcIkxhbmd1YWdlIFwiICsgaS5pZCk7XG4gICAgZi5hZGQoaSwgJ25leHRXb3JkJykubGlzdGVuKCk7XG4gICAgZi5hZGQoaSwgJ2FkZFdvcmQnKTtcbiAgICBmLmFkZChpLCAncG9wdWxhdGUnKTtcbiAgICBmLm9wZW4oKTtcbiAgICBjcmVhdGluZ0lzbGFuZCA9IHRydWU7XG4gIH1cbiAgdGhpcy5hZGRHYXRlID0gZnVuY3Rpb24oKXtcbiAgICBsZXQgZyA9IG5ldyBHYXRlKCk7XG4gICAgZ2F0ZXMucHVzaChnKTtcbiAgICBjcmVhdGluZ0dhdGUgPSB0cnVlO1xuICB9XG59XG5cbi8vd29yZCBwbGFjZWhvbGRlclxuXG5mdW5jdGlvbiBHYXRlKCl7XG4gIHRoaXMucG9pbnRzID0gW107XG59XG5cbi8vYWdlbnQgcGxhY2Vob2xkZXJcblxuLy9pc2xhbmQgcGxhY2Vob2xkZXJcblxuZnVuY3Rpb24gR3JpZEl0ZW0oeF8sIHlfLCB0eXBlXywgZ3hfLCBneV8pe1xuICAvL2l0ZW0ncyBsb2NhdGlvbiBvbiB0aGUgY2FudmFzXG4gIHRoaXMueCA9IHhfO1xuICB0aGlzLnkgPSB5XztcbiAgLy9pdGVtJ3MgbG9jYXRpb24gaW4gZ3JpZCBhcnJheVxuICB0aGlzLmdyaWRYID0gZ3hfO1xuICB0aGlzLmdyaWRZID0gZ3lfO1xuICB0aGlzLnR5cGUgPSB0eXBlXztcbiAgdGhpcy5jdXJyZW50QWdlbnQgPSBmYWxzZTtcbiAgdGhpcy5nYXRlVG87XG59XG5cbmZ1bmN0aW9uIHNldHVwKCl7XG4gIGNyZWF0ZUNhbnZhcygxNSAqIGZsb29yKHdpbmRvdy5pbm5lcldpZHRoIC8gMTUpLCAxNSAqIGZsb29yKHdpbmRvdy5pbm5lckhlaWdodC8xNSkpO1xuICBjb2xvck1vZGUoSFNMKTtcbiAgbm9TdHJva2UoKTtcbiAgdGV4dEZvbnQoXCJDb3VyaWVyIE5ld1wiKTtcblxuICBsb2dnZXIgPSBjcmVhdGVEaXYoXCJcIik7XG4gIGxvZ2dlci5pZChcImxvZ2dlclwiKTtcblxuICAvL2luaXRpYWxpemUgZ3VpXG4gIGN0cmwgPSBuZXcgQ29udHJvbHMoKTtcbiAgZ3VpID0gbmV3IGRhdC5HVUkoKTtcbiAgZ3VpLmFkZChjdHJsLCAnYWRkTGFuZ3VhZ2UnKTtcbiAgZ3VpLmFkZChjdHJsLCAnYWRkR2F0ZScpO1xuXG4gIC8vY3JlYXRlIGdyaWRcbiAgZm9yKGxldCBpID0gMDsgaSA8IHdpZHRoOyBpKz0xNSl7XG4gICAgbGV0IGNvbCA9IFtdO1xuICAgIGZvcihsZXQgaiA9IDA7IGogPCBoZWlnaHQ7IGorPTE1KXtcbiAgICAgIGNvbC5wdXNoKG5ldyBHcmlkSXRlbShpLCBqLCAnb2NlYW4nLCBncmlkLmxlbmd0aCwgY29sLmxlbmd0aCkpO1xuICAgIH1cbiAgICBncmlkLnB1c2goY29sKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkcmF3KCl7XG4gIGJhY2tncm91bmQoMjU1KTtcblxuICAvL2RyYXcgaXNsYW5kc1xuICBmb3IobGV0IGkgb2YgaXNsYW5kcyl7XG4gICAgZm9yKGxldCBwIG9mIGkucG9pbnRzKXtcbiAgICAgIGZpbGwoaS5jb2xvcik7XG4gICAgICByZWN0KHAueCwgcC55LCAxNSwgMTUpO1xuICAgIH1cbiAgfVxuXG4gIC8vZHJhdyBjdXJzb3JcbiAgZmlsbCg5MCk7XG4gIHJlY3QoMTUgKiBmbG9vcihtb3VzZVgvMTUpLCAxNSAqIGZsb29yKG1vdXNlWS8xNSksIDE1LCAxNSk7XG5cbiAgLy9jcmVhdGUgbmV3IGlzbGFuZHMgaWYgaW4gcHJvcGVyIG1vZGVcbiAgaWYobW91c2VJc1ByZXNzZWQpe1xuICAgIGlmKGNyZWF0aW5nSXNsYW5kICYmIGdyaWRbZmxvb3IobW91c2VYLzE1KV0gJiYgZ3JpZFtmbG9vcihtb3VzZVgvMTUpXVtmbG9vcihtb3VzZVkvMTUpXSl7XG4gICAgICAvL2lmIHdlIGhhdmVuJ3QgYWRkZWQgdGhpcyBwb2ludCB0byB0aGUgbmV3IGlzbGFuZCwgYWRkIGl0XG4gICAgICBpZighaXNsYW5kc1tpc2xhbmRzLmxlbmd0aCAtIDFdLnBvaW50cy5pbmNsdWRlcyhncmlkW2Zsb29yKG1vdXNlWC8xNSldW2Zsb29yKG1vdXNlWS8xNSldKSl7XG4gICAgICAgIGlzbGFuZHNbaXNsYW5kcy5sZW5ndGggLSAxXS5wb2ludHMucHVzaChncmlkW2Zsb29yKG1vdXNlWC8xNSldW2Zsb29yKG1vdXNlWS8xNSldKTtcbiAgICAgICAgLy9hbHNvIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgZ3JpZCB0aWxlIHRvIHRoZSBpc2xhbmQncyBpZFxuICAgICAgICBncmlkW2Zsb29yKG1vdXNlWC8xNSldW2Zsb29yKG1vdXNlWS8xNSldLnR5cGUgPSBpc2xhbmRzLmxlbmd0aCAtIDE7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yKGxldCBnIG9mIGdhdGVzKXtcbiAgICBzdHJva2UoODApO1xuICAgIGlmKGcucG9pbnRzLmxlbmd0aCA9PSAyKXtcbiAgICAgIGxpbmUoZy5wb2ludHNbMF0ueCArIDcuNSwgZy5wb2ludHNbMF0ueSArIDcuNSwgZy5wb2ludHNbMV0ueCArIDcuNSwgZy5wb2ludHNbMV0ueSArIDcuNSk7XG4gICAgfVxuICAgIG5vU3Ryb2tlKCk7XG4gICAgZm9yKGxldCBwIG9mIGcucG9pbnRzKXtcbiAgICAgIGZpbGwoOTUpO1xuICAgICAgcmVjdChwLngsIHAueSwgMTUsIDE1KTtcbiAgICB9XG4gIH1cblxuICAvL2RyYXcgYWdlbnRzXG4gIGZvcihsZXQgYWdlbnQgb2YgYWdlbnRzKXtcbiAgICBhZ2VudC5kcmF3KCk7XG4gIH1cblxuICBpZihsb2dnaW5nKXtcbiAgICBmaWxsKDQwKTtcbiAgICB0ZXh0U3R5bGUoTk9STUFMKTtcbiAgICB0ZXh0U2l6ZSg0OCk7XG4gICAgdGV4dChcIlJlbWFyay5cIiwgMTAsIDM2KTtcbiAgICB0ZXh0U2l6ZSgxOCk7XG4gICAgZmlsbCg2MCk7XG4gICAgdGV4dChcIkEgTGFuZ3VhZ2UgRXZvbHV0aW9uIFNpbXVsYXRvclwiLCAyMjUsIDM2KTtcbiAgICBmb3IobGV0IGkgPSAwOyBpIDwgaXNsYW5kcy5sZW5ndGg7IGkrKyl7XG4gICAgICBmaWxsKGlzbGFuZHNbaV0uY29sb3IpO1xuICAgICAgdGV4dFNpemUoMjgpO1xuICAgICAgcmVjdCgxNCwgNjcgKyAoaSAqIDcwKSwgMjAsIDUzKTtcbiAgICAgIGZpbGwoNDApO1xuICAgICAgdGV4dFN0eWxlKE5PUk1BTCk7XG4gICAgICB0ZXh0KFwiTGFuZ3VhZ2UgXCIgKyBpLCAzOSwgODUgKyAoaSAqIDcwKSk7XG4gICAgICB0ZXh0U2l6ZSgxOCk7XG4gICAgICB0ZXh0U3R5bGUoSVRBTElDKTtcbiAgICAgIGxldCB2b2NhYlN0cmluZyA9IFwiXCI7XG4gICAgICBmb3IobGV0IGogPSAwOyBqIDwgaXNsYW5kc1tpXS52b2NhYnVsYXJ5Lmxlbmd0aDsgaisrKXtcbiAgICAgICAgaWYoaiA+IDApe1xuICAgICAgICAgIHZvY2FiU3RyaW5nICs9IFwiLCBcIjtcbiAgICAgICAgfVxuICAgICAgICB2b2NhYlN0cmluZyArPSBpc2xhbmRzW2ldLnZvY2FidWxhcnlbal0uY29udGVudDtcbiAgICAgIH1cbiAgICAgIHRleHQodm9jYWJTdHJpbmcsIDM5LCAxMTAgKyAoaSAqIDcwKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vdXNlUHJlc3NlZCgpe1xuICBpZihjcmVhdGluZ0dhdGUpe1xuICAgIGxldCBjdXJyZW50R2F0ZSA9IGdhdGVzW2dhdGVzLmxlbmd0aCAtIDFdO1xuICAgIHN3aXRjaChjdXJyZW50R2F0ZS5wb2ludHMubGVuZ3RoKXtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgY3VycmVudEdhdGUucG9pbnRzLnB1c2goZ3JpZFtmbG9vcihtb3VzZVgvMTUpXVtmbG9vcihtb3VzZVkvMTUpXSk7XG4gICAgICAgIGdyaWRbZmxvb3IobW91c2VYLzE1KV1bZmxvb3IobW91c2VZLzE1KV0udHlwZSA9ICdnYXRlJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIGN1cnJlbnRHYXRlLnBvaW50cy5wdXNoKGdyaWRbZmxvb3IobW91c2VYLzE1KV1bZmxvb3IobW91c2VZLzE1KV0pO1xuICAgICAgICBncmlkW2Zsb29yKG1vdXNlWC8xNSldW2Zsb29yKG1vdXNlWS8xNSldLnR5cGUgPSAnZ2F0ZSc7XG5cbiAgICAgICAgbGV0IGFYID0gY3VycmVudEdhdGUucG9pbnRzWzBdLmdyaWRYO1xuICAgICAgICBsZXQgYVkgPSBjdXJyZW50R2F0ZS5wb2ludHNbMF0uZ3JpZFk7XG4gICAgICAgIGxldCBiWCA9IGN1cnJlbnRHYXRlLnBvaW50c1sxXS5ncmlkWDtcbiAgICAgICAgbGV0IGJZID0gY3VycmVudEdhdGUucG9pbnRzWzFdLmdyaWRZO1xuXG4gICAgICAgIGdyaWRbYVhdW2FZXS5nYXRlVG8gPSBncmlkW2JYXVtiWV07XG4gICAgICAgIGdyaWRbYlhdW2JZXS5nYXRlVG8gPSBncmlkW2FYXVthWV07XG5cbiAgICAgICAgY3JlYXRpbmdHYXRlID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VzZVJlbGVhc2VkKCl7XG4gIGlmKGNyZWF0aW5nSXNsYW5kKXtcbiAgICBjb25zb2xlLmxvZyhpc2xhbmRzW2lzbGFuZHMubGVuZ3RoLTFdKTtcbiAgICAvL3BvcHVsYXRlIGlzbGFuZCB3aXRoIGFnZW50c1xuICAgIC8vIGlzbGFuZHNbaXNsYW5kcy5sZW5ndGggLSAxXS5wb3B1bGF0ZShmbG9vcihyYW5kb20oaXNsYW5kc1tpc2xhbmRzLmxlbmd0aC0xXS5wb2ludHMubGVuZ3RoIC8gNCkpICsgMSk7XG4gICAgY3JlYXRpbmdJc2xhbmQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBrZXlQcmVzc2VkKCl7XG4gIHN3aXRjaChrZXlDb2RlKXtcbiAgICBjYXNlIDc2OlxuICAgICAgaWYobG9nZ2luZyl7XG4gICAgICAgIGxvZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgbG9nZ2VyLmhpZGUoKTtcbiAgICAgIH1lbHNle1xuICAgICAgICBsb2dnaW5nID0gdHJ1ZTtcbiAgICAgICAgbG9nZ2VyLnNob3coKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBjb25zb2xlLmxvZyhrZXlDb2RlKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG4iXSwiZmlsZSI6Im1haW4uanMifQ==

//# sourceMappingURL=main.min.js.map
